#!/usr/bin/env node

/**
 * Simple Jenkins AI Code Reviewer
 */

require('dotenv').config();
const fs = require('fs');
const { Octokit } = require('@octokit/rest');
const { CodeReviewer } = require('ai-reviewer-core');

// Input validation
function validateInputs(org, repo, pr) {
    if (!org || !repo || !pr) {
        throw new Error('Organization, repository, and PR number are required');
    }
    
    // Basic validation for org/repo names (alphanumeric, hyphens, underscores)
    if (!/^[a-zA-Z0-9_-]+$/.test(org) || !/^[a-zA-Z0-9_-]+$/.test(repo)) {
        throw new Error('Invalid organization or repository name');
    }
    
    // PR number should be numeric
    if (!/^\d+$/.test(pr)) {
        throw new Error('PR number must be numeric');
    }
}

// Simple argument parsing
function parseArgs() {
    const args = process.argv.slice(2);
    
    if (args.length < 3 || args.includes('--help') || args.includes('-h')) {
        console.log(`
Usage: ai-review <org> <repo> <pr> [output-file]

Arguments:
  org           Organization/owner name
  repo          Repository name  
  pr            Pull request number
  output-file   Output file (default: review-results.json)

Environment Variables:
  LLM_API_KEY     OpenAI API key
  LLM_ENDPOINT    OpenAI API endpoint
  GITHUB_TOKEN    GitHub API token (required for enterprise)
  GITHUB_BASE_URL GitHub base URL (default: https://api.github.com)
  POST_COMMENTS   Post comments to PR (true/false, default: true)
        `);
        process.exit(args.includes('--help') || args.includes('-h') ? 0 : 1);
    }

    return {
        org: args[0],
        repo: args[1], 
        pr: args[2],
        outputFile: args[3] || 'review-results.json'
    };
}

// Get diff from GitHub API using Octokit
async function getPullRequestDiff(org, repo, prNumber) {
    console.log('üì• Getting PR diff from GitHub API...');
    
    try {
        // Configure Octokit for GitHub Enterprise or public GitHub
        const githubToken = process.env.GITHUB_TOKEN;
        const githubBaseUrl = process.env.GITHUB_BASE_URL || 'https://api.github.com';
        
        if (!githubToken) {
            throw new Error('GITHUB_TOKEN environment variable is required');
        }
        
        const octokit = new Octokit({
            auth: githubToken,
            baseUrl: githubBaseUrl
        });
        
        console.log(`üîó Using GitHub API: ${githubBaseUrl}`);
        
        // Get PR diff using Octokit
        const response = await octokit.rest.pulls.get({
            owner: org,
            repo: repo,
            pull_number: parseInt(prNumber),
            mediaType: {
                format: 'diff'
            }
        });
        
        const diff = response.data;
        
        if (!diff || !diff.trim()) {
            throw new Error('No differences found in pull request');
        }
        
        console.log('‚úÖ Successfully retrieved PR diff');
        return diff;
        
    } catch (error) {
        if (error.status === 404) {
            throw new Error(`PR #${prNumber} not found in ${org}/${repo}`);
        } else if (error.status === 403) {
            throw new Error('GitHub API access denied. Check your GITHUB_TOKEN permissions.');
        } else if (error.status === 401) {
            throw new Error('GitHub API authentication failed. Check your GITHUB_TOKEN.');
        } else {
            throw new Error(`Failed to get PR diff: ${error.message}`);
        }
    }
}

// Post review comments back to GitHub PR
async function postReviewToGitHub(org, repo, prNumber, review) {
    const shouldPost = process.env.POST_COMMENTS !== 'false';
    if (!shouldPost) {
        console.log('‚è≠Ô∏è  Skipping GitHub comment posting (POST_COMMENTS=false)');
        return;
    }

    console.log('üìù Posting review comments to GitHub PR...');
    
    try {
        const githubToken = process.env.GITHUB_TOKEN;
        const githubBaseUrl = process.env.GITHUB_BASE_URL || 'https://api.github.com';
        
        const octokit = new Octokit({
            auth: githubToken,
            baseUrl: githubBaseUrl
        });

        // Post summary as a general PR comment
        if (review.summary && review.summary.trim()) {
            const summaryComment = `## ü§ñ AI Code Review Summary

${review.summary}

---
*Generated by AI Code Reviewer*`;

            await octokit.rest.issues.createComment({
                owner: org,
                repo: repo,
                issue_number: parseInt(prNumber),
                body: summaryComment
            });
            
            console.log('‚úÖ Posted summary comment to PR');
        }

        // Post line-specific comments if available
        if (review.comments && review.comments.length > 0) {
            let postedCount = 0;
            
            for (const comment of review.comments) {
                try {
                    // Only post if we have file path and line number
                    if (comment.file && comment.line) {
                        await octokit.rest.pulls.createReviewComment({
                            owner: org,
                            repo: repo,
                            pull_number: parseInt(prNumber),
                            body: `ü§ñ **AI Review:** ${comment.message}`,
                            path: comment.file,
                            line: comment.line,
                            side: 'RIGHT'  // Comment on the new version
                        });
                        postedCount++;
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è  Could not post comment for ${comment.file}:${comment.line}: ${error.message}`);
                }
            }
            
            if (postedCount > 0) {
                console.log(`‚úÖ Posted ${postedCount} line-specific comments`);
            } else {
                console.log('‚ÑπÔ∏è  No line-specific comments could be posted');
            }
        }

        console.log('üéâ Successfully posted review to GitHub PR!');
        
    } catch (error) {
        console.error(`‚ö†Ô∏è  Failed to post comments to GitHub: ${error.message}`);
        // Don't fail the entire review if posting comments fails
    }
}

// Main function
async function main() {
    // Parse arguments first (outside try-catch for error handling)
    const params = parseArgs();
    
    try {
        console.log('üöÄ Starting AI Code Review...');
        
        // Validate inputs
        validateInputs(params.org, params.repo, params.pr);
        
        // Check environment variables
        if (!process.env.LLM_API_KEY) {
            throw new Error('LLM_API_KEY environment variable is required');
        }
        
        if (!process.env.LLM_ENDPOINT) {
            throw new Error('LLM_ENDPOINT environment variable is required');
        }
        
        if (!process.env.GITHUB_TOKEN) {
            throw new Error('GITHUB_TOKEN environment variable is required');
        }
        
        // Get diff from GitHub API
        const diff = await getPullRequestDiff(params.org, params.repo, params.pr);
        
        // Initialize reviewer
        const reviewer = new CodeReviewer();
        
        // Perform review with new API
        console.log('ü§ñ Analyzing code with AI...');
        const review = await reviewer.reviewChanges(diff, {
            generateSummary: true
        });
        
        // Post review comments back to GitHub PR
        await postReviewToGitHub(params.org, params.repo, params.pr, review);
        
        // Write results
        const result = {
            success: true,
            repository: `${params.org}/${params.repo}`,
            pullRequest: params.pr,
            timestamp: new Date().toISOString(),
            summary: review.summary,
            comments: review.comments,
            hunks: review.hunks,
            metadata: review.metadata
        };
        
        fs.writeFileSync(params.outputFile, JSON.stringify(result, null, 2));
        
        console.log(`‚úÖ Review completed! Results saved to ${params.outputFile}`);
        
    } catch (error) {
        console.error(`‚ùå Error: ${error.message}`);
        
        // Write error result
        const errorResult = {
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        };
        
        fs.writeFileSync(params.outputFile, JSON.stringify(errorResult, null, 2));
        
        process.exit(1);
    }
}

// Run if called directly
if (require.main === module) {
    main();
}

module.exports = { main };