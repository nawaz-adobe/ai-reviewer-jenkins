const { main } = require('../../src/index');
const { Octokit } = require('@octokit/rest');
const fs = require('fs');
const path = require('path');

// Real integration tests for GitHub API functionality
describe('GitHub API Integration Tests', () => {
    // Test environment variables
    const testRepo = {
        org: process.env.TEST_GITHUB_ORG || 'nawaz-adobe',
        repo: process.env.TEST_GITHUB_REPO || 'ai-reviewer-mock',
        pr: process.env.TEST_GITHUB_PR || '1'
    };

    const hasCredentials = () => {
        return process.env.GITHUB_TOKEN && 
               process.env.LLM_API_KEY && 
               process.env.LLM_ENDPOINT;
    };

    beforeAll(() => {
        if (!hasCredentials()) {
            console.warn('âš ï¸  Skipping GitHub integration tests - missing credentials');
            console.warn('Set GITHUB_TOKEN, LLM_API_KEY, LLM_ENDPOINT to run');
        }
    });

    describe('GitHub PR Diff Retrieval', () => {
        (hasCredentials() ? test : test.skip)('should fetch PR diff via GitHub API', async () => {
            // Use Octokit directly to test the API
            const octokit = new Octokit({
                auth: process.env.GITHUB_TOKEN,
                baseUrl: process.env.GITHUB_BASE_URL || 'https://api.github.com'
            });

            const response = await octokit.rest.pulls.get({
                owner: testRepo.org,
                repo: testRepo.repo,
                pull_number: parseInt(testRepo.pr),
                mediaType: { format: 'diff' }
            });

            expect(response.data).toBeDefined();
            expect(typeof response.data).toBe('string');
            expect(response.data.length).toBeGreaterThan(0);
            
            // Should be a valid diff format
            expect(response.data).toMatch(/diff --git/);
        }, 30000);

        (hasCredentials() ? test : test.skip)('should handle non-existent PR', async () => {
            const octokit = new Octokit({
                auth: process.env.GITHUB_TOKEN,
                baseUrl: process.env.GITHUB_BASE_URL || 'https://api.github.com'
            });

            await expect(octokit.rest.pulls.get({
                owner: testRepo.org,
                repo: testRepo.repo,
                pull_number: 99999, // Non-existent PR
                mediaType: { format: 'diff' }
            })).rejects.toThrow();
        }, 10000);
    });

    describe('Comment Posting', () => {
        (hasCredentials() ? test : test.skip)('should post comments to PR (if TEST_ENABLE_COMMENT_POSTING=true)', async () => {
            // Only run if explicitly enabled to avoid spamming PRs
            if (process.env.TEST_ENABLE_COMMENT_POSTING !== 'true') {
                console.log('Skipping comment posting test - set TEST_ENABLE_COMMENT_POSTING=true to enable');
                return;
            }

            const octokit = new Octokit({
                auth: process.env.GITHUB_TOKEN,
                baseUrl: process.env.GITHUB_BASE_URL || 'https://api.github.com'
            });

            // Post a test comment
            const testComment = `ðŸ§ª **Test Comment** - ${new Date().toISOString()}

This is an automated test comment from the AI reviewer integration tests.
It will be cleaned up automatically.

---
*Generated by AI Code Reviewer Integration Tests*`;

            const response = await octokit.rest.issues.createComment({
                owner: testRepo.org,
                repo: testRepo.repo,
                issue_number: parseInt(testRepo.pr),
                body: testComment
            });

            expect(response.status).toBe(201);
            expect(response.data.id).toBeDefined();

            // Clean up - delete the test comment
            await octokit.rest.issues.deleteComment({
                owner: testRepo.org,
                repo: testRepo.repo,
                comment_id: response.data.id
            });

            console.log('âœ… Test comment posted and cleaned up successfully');
        }, 15000);
    });

    describe('End-to-End Review Flow', () => {
        (hasCredentials() ? test : test.skip)('should complete full review workflow (dry run)', async () => {
            // Set up test environment
            const originalArgv = process.argv;
            const originalCwd = process.cwd();
            const testOutputFile = path.join(__dirname, 'test-review-results.json');

            try {
                // Mock command line arguments
                process.argv = [
                    'node',
                    'ai-review',
                    testRepo.org,
                    testRepo.repo, 
                    testRepo.pr,
                    testOutputFile
                ];

                // Disable comment posting for this test
                process.env.POST_COMMENTS = 'false';

                // Mock process.exit to prevent test termination
                const originalExit = process.exit;
                let exitCode = null;
                process.exit = jest.fn((code) => { exitCode = code; });

                // Run the main function
                await main();

                // Restore process.exit
                process.exit = originalExit;

                // Check if it completed successfully (exit code 0 or null)
                expect(exitCode).toBeNull();

                // Verify output file was created
                expect(fs.existsSync(testOutputFile)).toBe(true);

                // Verify output structure
                const results = JSON.parse(fs.readFileSync(testOutputFile, 'utf8'));
                expect(results.success).toBe(true);
                expect(results.repository).toBe(`${testRepo.org}/${testRepo.repo}`);
                expect(results.pullRequest).toBe(testRepo.pr);
                expect(results.timestamp).toBeDefined();
                expect(results.summary).toBeDefined();
                expect(results.metadata).toBeDefined();

                console.log('âœ… End-to-end test completed successfully');
                console.log(`ðŸ“„ Results: ${JSON.stringify(results, null, 2).substring(0, 200)}...`);

            } finally {
                // Restore environment
                process.argv = originalArgv;
                process.cwd = originalCwd;
                delete process.env.POST_COMMENTS;

                // Clean up test file
                if (fs.existsSync(testOutputFile)) {
                    fs.unlinkSync(testOutputFile);
                }
            }
        }, 60000);
    });

    describe('Error Handling', () => {
        test('should handle missing GitHub token', async () => {
            const originalToken = process.env.GITHUB_TOKEN;
            const originalExit = process.exit;
            delete process.env.GITHUB_TOKEN;

            const originalArgv = process.argv;
            process.argv = ['node', 'ai-review', 'test', 'test', '1'];

            let exitCode = null;
            process.exit = jest.fn((code) => { exitCode = code; });

            try {
                await main();
                expect(exitCode).toBe(1); // Should exit with error code
            } finally {
                process.env.GITHUB_TOKEN = originalToken;
                process.argv = originalArgv;
                process.exit = originalExit;
            }
        });

        test('should handle missing LLM credentials', async () => {
            const originalApiKey = process.env.LLM_API_KEY;
            const originalExit = process.exit;
            delete process.env.LLM_API_KEY;

            const originalArgv = process.argv;
            process.argv = ['node', 'ai-review', 'test', 'test', '1'];

            let exitCode = null;
            process.exit = jest.fn((code) => { exitCode = code; });

            try {
                await main();
                expect(exitCode).toBe(1); // Should exit with error code
            } finally {
                process.env.LLM_API_KEY = originalApiKey;
                process.argv = originalArgv;
                process.exit = originalExit;
            }
        });

        test('should validate PR number format', async () => {
            const originalArgv = process.argv;
            const originalExit = process.exit;
            process.argv = ['node', 'ai-review', 'test', 'test', 'invalid-pr'];

            let exitCode = null;
            process.exit = jest.fn((code) => { exitCode = code; });

            try {
                await main();
                expect(exitCode).toBe(1); // Should exit with error code
            } finally {
                process.argv = originalArgv;
                process.exit = originalExit;
            }
        });
    });

    describe('Enterprise GitHub Support', () => {
        (process.env.GITHUB_BASE_URL && hasCredentials() ? test : test.skip)('should work with enterprise GitHub', async () => {
            // This test only runs if GITHUB_BASE_URL is set (indicating enterprise usage)
            console.log(`Testing with enterprise GitHub: ${process.env.GITHUB_BASE_URL}`);

            const octokit = new Octokit({
                auth: process.env.GITHUB_TOKEN,
                baseUrl: process.env.GITHUB_BASE_URL
            });

            // Test basic API connectivity
            const response = await octokit.rest.repos.get({
                owner: testRepo.org,
                repo: testRepo.repo
            });

            expect(response.status).toBe(200);
            expect(response.data.name).toBe(testRepo.repo);
            console.log('âœ… Enterprise GitHub API connection successful');
        }, 10000);
    });
});
